<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vantage Method - Marketing Systems That Work</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@300;400;500;600;700&family=Barlow+Condensed:wght@600;700;800;900&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="index.css">
</head>
<body>
    <!-- Header -->
    <header>
        <div class="container">
            <img src="Rsources/Vantage-Method-Dark.png" alt="Vantage Method" class="logo">
            <nav>
                <a href="#contact">Book a call</a>
            </nav>
        </div>
    </header>

    <!-- Hero Section -->
    <section class="hero">
        <div class="container">
            <div class="hero-content">
                <h1>
                    NEW <span class="hero-rotating-wrapper">
                        <span class="hero-rotating-phrase">CUSTOMERS.</span>
                        <span class="hero-rotating-phrase">LEADS.</span>
                        <span class="hero-rotating-phrase">OPPORTUNITIES.</span>
                    </span><br>
                    At a cost your business can actually support.
                </h1>
                <p class="hero-subtext">
                    We design and operate agentic marketing systems that automate the boring work, measure what matters, and keep you focused on your company.
                </p>
                <div class="hero-buttons">
                    <a href="#contact" class="hero-cta">Book A Call</a>
                    <a href="#outcome" class="hero-cta-secondary">Our Approach</a>
                </div>
            </div>
        </div>
    </section>

    <!-- Mountain Section 1: The Outcome -->
    <section class="mountain-section" id="outcome">
        <div class="side-mountains-container" id="sideMountains">
            <img src="Rsources/Mountains/left-mountain.png" alt="Left Mountain" class="left-mountain" id="leftMountain">
            <img src="Rsources/Mountains/righ-mountain.png" alt="Right Mountain" class="right-mountain" id="rightMountain">
        </div>
        <div class="center-mountain-container">
            <img src="Rsources/Mountains/center-mountain-back.png" alt="Mountain Background" class="center-mountain" style="z-index: 0;">
            <img src="Rsources/Mountains/center-mountain-middle.png" alt="Mountain Middle" class="center-mountain center-mountain-middle" id="centerMountainMiddle" style="z-index: 1;">
            <img src="Rsources/Mountains/center-mountain-front.png" alt="Mountain Front" class="center-mountain" style="z-index: 2;">
        </div>
        <div class="content-block" id="outcomeBlock">
            <div class="block-title">The Outcome</div>
            <div class="block-content">
                <p>Not just more <span class="rotating-wrapper">
                    <span class="rotating-phrase">leads.</span>
                    <span class="rotating-phrase">customers.</span>
                    <span class="rotating-phrase">opportunities.</span>
                </span></p>
                <p><span class="highlight-text">Better ones</span> — at the right price.</p>
                <div class="block-divider"></div>
                <ul>
                    <li class="icon-demand">Predictable demand</li>
                    <li class="icon-attribution">Clear attribution</li>
                    <li class="icon-opportunities">Qualified opportunities</li>
                </ul>
            </div>
            <a href="#how" class="block-cta">How we get there</a>
        </div>
    </section>

    <!-- Mountain Section 2: How We Get There -->
    <section class="mountain-section" id="how">
        <div class="content-block" id="howBlock">
            <div class="block-title">How We Get There</div>
            <div class="block-content">
                <p>We don't start with ads. <span class="highlight-text">We start with your business.</span></p>
                <div class="block-divider"></div>
                <p><strong>Marketing only works when it fits inside:</strong></p>
                <ul>
                    <li class="icon-margins">margins</li>
                    <li class="icon-capacity">capacity</li>
                    <li class="icon-systems">systems</li>
                </ul>
            </div>
            <a href="#where" class="block-cta">Where we start</a>
        </div>
    </section>

    <!-- Mountain Section 3: Where It Actually Begins -->
    <section class="mountain-section" id="where">
        <div class="content-block" id="whereBlock">
            <div class="block-title">Where It Actually Begins</div>
            <div class="block-content">
                <p>Before we spend a dollar on marketing, we reverse-engineer how <span class="highlight-text">your business makes money</span> — and whether marketing can responsibly accelerate it.</p>
                <div class="block-divider"></div>
                <p><strong>This is where:</strong></p>
                <ul>
                    <li class="icon-waste">waste is removed</li>
                    <li class="icon-automation">automation is applied</li>
                    <li class="icon-humans">humans stay in their wheelhouse</li>
                </ul>
            </div>
            <a href="#principles" class="block-cta">Our Principles</a>
        </div>
    </section>

    <!-- Principles Section -->
    <section class="content-section" id="principles">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title">Our Principles</h2>
                <p class="section-subtitle principles-subtitle">Measure. Automate. Focus.</p>
            </div>
            <div class="principles-grid">
                <div class="principle-card">
                    <div class="principle-icon icon-data"></div>
                    <h3 class="principle-title">Data First</h3>
                    <p class="principle-description">We carefully measure the data that actually matters.</p>
                </div>
                <div class="principle-card">
                    <div class="principle-icon icon-automate"></div>
                    <h3 class="principle-title">Automate Everything</h3>
                    <p class="principle-description">We automate the boring, repetitive work — not the human touch.</p>
                </div>
                <div class="principle-card">
                    <div class="principle-icon icon-focus"></div>
                    <h3 class="principle-title">Work in Your Sweet Spot</h3>
                    <p class="principle-description">You do the work that only you can do. The work that matters most.</p>
                </div>
            </div>
            <a href="#how-we-work" class="section-nav-button">See How We Work</a>
        </div>
    </section>

    <!-- How We Work Section -->
    <section class="content-section alt-bg" id="how-we-work">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title">How We Work</h2>
                <p class="section-subtitle">Discipline. Constraints. Reality.</p>
            </div>
            <div class="how-work-content">
                <div class="how-work-statement">
                    <h3 class="statement-headline">Most marketing fails because it ignores the business.</h3>
                </div>
                
                <div class="how-work-approach">
                    <div class="approach-block">
                        <div class="approach-animation">
                            <canvas class="animation-canvas" id="engineerCanvas"></canvas>
                        </div>
                        <div class="approach-content">
                            <h4>Business Model Analysis</h4>
                            <p>We reverse-engineer your business model, identify where marketing fits, and apply automation where it replaces wasted effort.</p>
                        </div>
                    </div>
                    
                    <div class="approach-block">
                        <div class="approach-animation">
                            <canvas class="animation-canvas" id="systemCanvas"></canvas>
                        </div>
                        <div class="approach-content">
                            <h4>Critical System Design</h4>
                            <p>We design marketing systems the same way you'd design any critical system: with discipline, constraints, and respect for reality.</p>
                        </div>
                    </div>
                    
                    <div class="approach-block">
                        <div class="approach-animation">
                            <canvas class="animation-canvas" id="aiCanvas"></canvas>
                            <img src="Rsources/Vantage-Method-Light.png" class="animation-logo" alt="Vantage Method">
                        </div>
                        <div class="approach-content">
                            <h4>AI is used deliberately.</h4>
                            <p>We use it where it excels — repetition, analysis, orchestration. We keep humans involved where judgment, creativity, and accountability matter.</p>
                        </div>
                    </div>
                </div>
            </div>
            <a href="#what-we-do" class="section-nav-button">What We Do</a>
        </div>
    </section>

    <!-- What We Do Section -->
    <section class="content-section" id="what-we-do">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title">What We Do</h2>
                <p class="section-subtitle">Analyze. Execute. Partner.</p>
            </div>
            <div class="pillars-grid">
                <!-- Pillar 1 -->
                <div class="pillar-card">
                    <div class="pillar-number">Pillar 1</div>
                    <h3 class="pillar-title">Business Analysis & AI Discovery</h3>
                    <p class="pillar-description">Before we execute, we evaluate whether marketing can responsibly accelerate your business.</p>
                    <div class="block-divider"></div>
                    <ul class="pillar-list">
                        <li>Company profile and executive summary</li>
                        <li>Revenue and margin analysis</li>
                        <li>Customer avatar and buying journey</li>
                        <li>Lead-to-close process review</li>
                        <li>Marketing budget feasibility</li>
                    </ul>
                    <div class="block-divider"></div>
                    <p class="pillar-note">The outcome is clarity — on what to automate, what to measure, and whether a partnership makes sense.</p>
                </div>

                <!-- Pillar 2 -->
                <div class="pillar-card">
                    <div class="pillar-number">Pillar 2</div>
                    <h3 class="pillar-title">End-to-End Marketing Systems</h3>
                    <p class="pillar-description">Once the foundation is sound, we build and operate marketing systems from strategy through execution.</p>
                    <div class="block-divider"></div>
                    <ul class="pillar-list">
                        <li>Brand positioning and messaging</li>
                        <li>Website and conversion optimization</li>
                        <li>Paid advertising across channels</li>
                        <li>Email and lifecycle campaigns</li>
                        <li>Lead qualification and handoff systems</li>
                    </ul>
                    <div class="block-divider"></div>
                    <p class="pillar-note">Marketing does not stop at traffic. It ends when a qualified opportunity is delivered to the business.</p>
                </div>

                <!-- Pillar 3 -->
                <div class="pillar-card">
                    <div class="pillar-number">Pillar 3</div>
                    <h3 class="pillar-title">Marketing for Equity (Selective)</h3>
                    <p class="pillar-description">For businesses with strong fundamentals but limited capital, we offer a long-term partnership model.</p>
                    <div class="block-divider"></div>
                    <ul class="pillar-list">
                        <li>Full marketing function operation</li>
                        <li>Long-term partnership alignment</li>
                        <li>Equity and/or profit participation</li>
                        <li>Application and formal evaluation</li>
                        <li>Clear product-market fit required</li>
                    </ul>
                    <div class="block-divider"></div>
                    <p class="pillar-note">We only partner where we believe deeply in the outcome and where shared incentives align.</p>
                </div>
            </div>
            <a href="#team" class="section-nav-button">Meet The Team</a>
        </div>
    </section>

    <!-- Team Section -->
    <section class="content-section alt-bg" id="team">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title">The Team</h2>
                <p class="section-subtitle">The team bringing your vision to life.</p>
            </div>
            <div class="team-orbit-container">
                <canvas id="teamConnectionLines" class="team-connection-canvas"></canvas>
                
                <div class="team-center-text">
                    Your Company
                    <span class="team-center-subtext">Find out more</span>
                </div>
                
                <div class="team-members">
                    <div class="team-member" data-member="0" data-name="Westin" data-title="Strategy & Growth" data-bio="Designs go-to-market systems that align with business fundamentals.">
                        <a href="#" class="member-photo" style="background-image: url('Rsources/Team/Westin.jpg');"></a>
                    </div>
                    <div class="team-member" data-member="1" data-name="Daniel" data-title="Brand & Design" data-bio="Oversees visual identity and creative execution across all channels.">
                        <a href="#" class="member-photo" style="background-image: url('Rsources/Team/Daniel.jpg');"></a>
                    </div>
                    <div class="team-member" data-member="2" data-name="Matthew" data-title="AI & Systems" data-bio="Builds and maintains automation infrastructure for efficiency at scale.">
                        <a href="#" class="member-photo" style="background-image: url('Rsources/Team/Matthew.jpg');"></a>
                    </div>
                    <div class="team-member" data-member="3" data-name="Randy" data-title="Trans Activist" data-bio="Manages paid acquisition channels and conversion optimization.">
                        <a href="#" class="member-photo randy-photo" style="background-image: url('Rsources/Team/Randy 2.jpg');"></a>
                    </div>
                    <div class="team-member" data-member="4" data-name="Scott" data-title="Content & SEO" data-bio="Develops content strategy and organic growth initiatives.">
                        <a href="#" class="member-photo" style="background-image: url('Rsources/Team/Scott.jpg');"></a>
                    </div>
                    <div class="team-member" data-member="5" data-name="Kenny" data-title="Data & Insights" data-bio="Tracks performance metrics and ensures data-driven decision making.">
                        <a href="#" class="member-photo" style="background-image: url('Rsources/Team/Kenny.jpg');"></a>
                    </div>
                    <div class="team-member" data-member="6" data-name="Zach" data-title="Project Management" data-bio="Coordinates workflows and ensures timely delivery across all projects.">
                        <a href="#" class="member-photo" style="background-image: url('Rsources/Team/Zach.jpg');"></a>
                    </div>
                    <div class="team-member" data-member="7" data-name="Dwight" data-title="Technical Implementation" data-bio="Handles technical integrations and custom development requirements.">
                        <a href="#" class="member-photo" style="background-image: url('Rsources/Team/Dwight.jpg');"></a>
                    </div>
                </div>
                
                <div class="team-bio-card" id="teamBioCard">
                    <h4 class="bio-name"></h4>
                    <p class="bio-title"></p>
                    <p class="bio-description"></p>
                </div>
            </div>
            <a href="#pricing" class="section-nav-button">Partnership & Pricing</a>
        </div>
    </section>

    <!-- Pricing Section -->
    <section class="content-section" id="pricing">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title">Partnership & Pricing</h2>
            </div>
            <div class="pricing-content">
                <p><strong>There is no flat pricing. Because there is no flat business.</strong></p>
                <p>Every engagement begins with evaluation. Pricing is aligned to feasibility, scope, and expected return.</p>
                <span class="emphasis">In the right cases, partnership replaces retainers.</span>
            </div>
            <div class="pricing-buttons">
                <a href="#contact" class="pricing-cta-button">Get Started</a>
                <a href="#contact" class="pricing-cta-button secondary">Explore Partnerships</a>
            </div>
        </div>
    </section>

    <!-- CTA Section -->
    <section class="cta-section" id="contact">
        <div class="cta-mountains-container" id="ctaMountains">
            <img src="Rsources/Mountains/left-mountain.png" alt="Left Mountain" class="cta-left-mountain">
            <img src="Rsources/Mountains/righ-mountain.png" alt="Right Mountain" class="cta-right-mountain">
        </div>
        <div class="container">
            <h2 class="cta-title">Start Here</h2>
            <p class="cta-subtitle">This is an <span class="highlight-evaluation">evaluation.</span> Not a pitch.</p>
            <div class="cta-questions" id="ctaQuestions">
                <div class="cta-question-card slide-left offset-1">
                    <span class="question-icon icon-lead"></span>
                    <span class="question-text">What does a qualified lead mean for your business?</span>
                </div>
                <div class="cta-question-card slide-right offset-2">
                    <span class="question-icon icon-value"></span>
                    <span class="question-text">What is one customer actually worth?</span>
                </div>
                <div class="cta-question-card slide-left offset-3">
                    <span class="question-icon icon-systems-break"></span>
                    <span class="question-text">Where are systems breaking today?</span>
                </div>
            </div>
            <a href="mailto:hello@vantagemethod.com" class="cta-button" id="ctaButton">Let's Talk</a>
        </div>
    </section>

    <!-- Scripts -->
    <script>
        // Hero rotating text animation
        const heroRotatingPhrases = document.querySelectorAll('.hero-rotating-phrase');
        let currentHeroPhraseIndex = 0;

        function rotateHeroPhrase() {
            heroRotatingPhrases[currentHeroPhraseIndex].classList.remove('active');
            setTimeout(() => {
                currentHeroPhraseIndex = (currentHeroPhraseIndex + 1) % heroRotatingPhrases.length;
                heroRotatingPhrases[currentHeroPhraseIndex].classList.add('active');
            }, 500);
        }

        if (heroRotatingPhrases.length > 0) {
            heroRotatingPhrases[0].classList.add('active');
            setInterval(rotateHeroPhrase, 3500);
        }

        // Block rotating text animation
        const rotatingPhrases = document.querySelectorAll('.rotating-phrase');
        let currentPhraseIndex = 0;

        function rotatePhrase() {
            rotatingPhrases[currentPhraseIndex].classList.remove('active');
            setTimeout(() => {
                currentPhraseIndex = (currentPhraseIndex + 1) % rotatingPhrases.length;
                rotatingPhrases[currentPhraseIndex].classList.add('active');
            }, 500);
        }

        if (rotatingPhrases.length > 0) {
            rotatingPhrases[0].classList.add('active');
            setInterval(rotatePhrase, 3500);
        }

        // Background mountains scroll animation (Desktop only)
        const leftMountain = document.getElementById('leftMountain');
        const rightMountain = document.getElementById('rightMountain');
        const firstMountainSection = document.getElementById('outcome');

        function updateBackgroundMountains() {
            if (window.innerWidth <= 768) return; // Skip on mobile
            
            const scrollY = window.scrollY;
            const windowHeight = window.innerHeight;
            
            if (!firstMountainSection) return;
            
            const sectionTop = firstMountainSection.offsetTop;
            const sectionHeight = firstMountainSection.offsetHeight;
            
            // Calculate scroll progress through the mountain sections
            const scrollProgress = Math.max(0, Math.min(1, (scrollY - sectionTop + windowHeight) / (sectionHeight + windowHeight)));
            
            // Mountains start higher (-100px) and move down to final position (-600px)
            const startPosition = -100;
            const endPosition = -600;
            const currentPosition = startPosition + (scrollProgress * (endPosition - startPosition));
            
            if (leftMountain) leftMountain.style.bottom = `${currentPosition}px`;
            if (rightMountain) rightMountain.style.bottom = `${currentPosition}px`;
        }

        window.addEventListener('scroll', updateBackgroundMountains, { passive: true });
        updateBackgroundMountains();

        // Middle mountain layer reveal animation
        const centerMountainMiddle = document.getElementById('centerMountainMiddle');
        const mountainSections = document.querySelectorAll('.mountain-section');

        function updateMiddleMountainReveal() {
            const scrollY = window.scrollY;
            const windowHeight = window.innerHeight;
            
            if (mountainSections.length === 0) return;
            
            const firstSection = mountainSections[0];
            const lastSection = mountainSections[mountainSections.length - 1];
            
            const sectionTop = firstSection.offsetTop;
            const bottomSectionBottom = lastSection.offsetTop + lastSection.offsetHeight;
            
            const triggerPoint = sectionTop - (windowHeight / 2);
            const endPoint = bottomSectionBottom - windowHeight;
            
            const totalRevealDistance = endPoint - triggerPoint;
            const scrollProgress = Math.max(0, Math.min(1, (scrollY - triggerPoint) / totalRevealDistance));
            
            const revealPercent = scrollProgress * 100;
            if (centerMountainMiddle) {
                centerMountainMiddle.style.setProperty('--reveal-progress', `${revealPercent}%`);
            }
        }

        window.addEventListener('scroll', updateMiddleMountainReveal, { passive: true });
        updateMiddleMountainReveal();

        // Content blocks visibility animation
        const contentBlocks = [
            { element: document.getElementById('outcomeBlock'), section: document.getElementById('outcome'), triggered: false },
            { element: document.getElementById('howBlock'), section: document.getElementById('how'), triggered: false },
            { element: document.getElementById('whereBlock'), section: document.getElementById('where'), triggered: false }
        ];

        function updateBlocksVisibility() {
            const scrollY = window.scrollY;
            const windowHeight = window.innerHeight;

            contentBlocks.forEach(block => {
                if (!block.element || !block.section || block.triggered) return;

                // Use section position for better detection on desktop
                const sectionTop = block.section.offsetTop;
                const sectionHeight = block.section.offsetHeight;
                const sectionCenter = sectionTop + (sectionHeight / 2);

                // Trigger when section center reaches viewport center
                if (scrollY + (windowHeight / 2) > sectionCenter - 100) {
                    block.element.classList.add('visible');
                    block.triggered = true;
                }
            });
        }

        window.addEventListener('scroll', updateBlocksVisibility, { passive: true });
        updateBlocksVisibility();

        // Pillar cards animation
        const pillarCards = document.querySelectorAll('.pillar-card');
        let pillarCardsTriggered = false;

        function updatePillarCards() {
            if (pillarCardsTriggered || pillarCards.length === 0) return;

            const scrollY = window.scrollY;
            const windowHeight = window.innerHeight;
            const firstCard = pillarCards[0];
            const cardTop = firstCard.offsetTop;

            if (scrollY + windowHeight > cardTop + 100) {
                pillarCards.forEach((card, index) => {
                    setTimeout(() => {
                        card.classList.add('visible');
                    }, index * 150);
                });
                pillarCardsTriggered = true;
            }
        }

        window.addEventListener('scroll', updatePillarCards, { passive: true });
        updatePillarCards();

        // Principle cards animation
        const principleCards = document.querySelectorAll('.principle-card');
        let principleCardsTriggered = false;

        function updatePrincipleCards() {
            if (principleCardsTriggered || principleCards.length === 0) return;

            const scrollY = window.scrollY;
            const windowHeight = window.innerHeight;
            const principlesSection = document.getElementById('principles');
            
            if (principlesSection) {
                // Use section position for better detection - same logic as content blocks
                const sectionTop = principlesSection.offsetTop;
                const sectionHeight = principlesSection.offsetHeight;
                const sectionCenter = sectionTop + (sectionHeight / 2);

                // Trigger when section center reaches viewport center
                if (scrollY + (windowHeight / 2) > sectionCenter - 100) {
                    principleCards.forEach((card, index) => {
                        setTimeout(() => {
                            card.classList.add('visible');
                        }, index * 200);
                    });
                    principleCardsTriggered = true;
                }
            }
        }

        window.addEventListener('scroll', updatePrincipleCards, { passive: true });
        updatePrincipleCards();

        // Approach blocks animation
        const approachBlocks = document.querySelectorAll('.approach-block');
        let approachBlocksTriggered = false;

        function updateApproachBlocks() {
            if (approachBlocksTriggered || approachBlocks.length === 0) return;

            const scrollY = window.scrollY;
            const windowHeight = window.innerHeight;
            const firstBlock = approachBlocks[0];
            const blockTop = firstBlock.offsetTop;

            if (scrollY + windowHeight > blockTop + 100) {
                approachBlocks.forEach((block, index) => {
                    setTimeout(() => {
                        block.classList.add('visible');
                    }, index * 150);
                });
                approachBlocksTriggered = true;
            }
        }

        window.addEventListener('scroll', updateApproachBlocks, { passive: true });
        updateApproachBlocks();

        // Interactive canvas animations for How We Work blocks
        function initCanvasAnimation(canvasId, drawFunc) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const parent = canvas.parentElement;
            
            const state = {
                w: 0,
                h: 0,
                time: 0,
                hovering: false,
                mouseX: 0,
                mouseY: 0,
                raf: 0
            };
            
            function resize() {
                const rect = parent.getBoundingClientRect();
                state.w = rect.width;
                state.h = rect.height;
                canvas.width = state.w;
                canvas.height = state.h;
            }
            
            function updateMouse(e) {
                const rect = canvas.getBoundingClientRect();
                state.mouseX = e.clientX - rect.left;
                state.mouseY = e.clientY - rect.top;
            }
            
            canvas.addEventListener('pointerenter', (e) => {
                state.hovering = true;
                updateMouse(e);
            });
            canvas.addEventListener('pointermove', updateMouse);
            canvas.addEventListener('pointerleave', () => {
                state.hovering = false;
            });
            
            function animate() {
                state.time += 0.016;
                ctx.clearRect(0, 0, state.w, state.h);
                drawFunc(ctx, state);
                state.raf = requestAnimationFrame(animate);
            }
            
            resize();
            window.addEventListener('resize', resize);
            animate();
        }

        // Animation 1: Critical System Design - Flow particles navigating through constraints
        initCanvasAnimation('systemCanvas', (ctx, state) => {
            // Initialize particles if not exists
            if (!state.particles || state.particles.length === 0) {
                state.particles = [];
                state.constraints = [];
                
                // Create constraint barriers (representing real-world limitations)
                const barrierCount = 4;
                for (let i = 0; i < barrierCount; i++) {
                    const x = state.w * (0.2 + i * 0.2);
                    const gapY = state.h * (0.3 + Math.sin(i) * 0.2);
                    const gapSize = state.h * 0.3;
                    state.constraints.push({
                        x: x,
                        gapY: gapY,
                        gapSize: gapSize
                    });
                }
                
                // Create flow particles
                for (let i = 0; i < 30; i++) {
                    state.particles.push({
                        x: -20,
                        y: state.h / 2 + (Math.random() - 0.5) * state.h * 0.4,
                        vx: 1 + Math.random() * 0.5,
                        vy: 0,
                        phase: Math.random() * Math.PI * 2,
                        trail: []
                    });
                }
            }
            
            // Update constraint barriers (subtle breathing animation)
            state.constraints.forEach((c, i) => {
                c.gapY = state.h * (0.3 + Math.sin(state.time * 0.5 + i) * 0.15);
            });
            
            // Draw constraint barriers
            ctx.strokeStyle = '#007c87';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.3;
            
            state.constraints.forEach(barrier => {
                // Top barrier
                ctx.beginPath();
                ctx.moveTo(barrier.x, 0);
                ctx.lineTo(barrier.x, barrier.gapY - barrier.gapSize / 2);
                ctx.stroke();
                
                // Bottom barrier
                ctx.beginPath();
                ctx.moveTo(barrier.x, barrier.gapY + barrier.gapSize / 2);
                ctx.lineTo(barrier.x, state.h);
                ctx.stroke();
                
                // Draw gap indicators
                ctx.globalAlpha = 0.5;
                const gapTop = barrier.gapY - barrier.gapSize / 2;
                const gapBottom = barrier.gapY + barrier.gapSize / 2;
                
                // Top arrow
                ctx.beginPath();
                ctx.moveTo(barrier.x - 6, gapTop - 8);
                ctx.lineTo(barrier.x, gapTop - 2);
                ctx.lineTo(barrier.x + 6, gapTop - 8);
                ctx.stroke();
                
                // Bottom arrow
                ctx.beginPath();
                ctx.moveTo(barrier.x - 6, gapBottom + 8);
                ctx.lineTo(barrier.x, gapBottom + 2);
                ctx.lineTo(barrier.x + 6, gapBottom + 8);
                ctx.stroke();
                
                ctx.globalAlpha = 0.3;
            });
            
            // Update and draw particles
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#007c87';
            
            state.particles.forEach(p => {
                // Store trail
                p.trail.push({ x: p.x, y: p.y });
                if (p.trail.length > 15) p.trail.shift();
                
                // Navigate toward gaps in constraints
                let targetY = p.y;
                const lookAhead = 50;
                
                for (let c of state.constraints) {
                    if (p.x < c.x && p.x + lookAhead > c.x) {
                        targetY = c.gapY;
                        break;
                    }
                }
                
                // Smooth steering toward target
                const dy = targetY - p.y;
                p.vy += dy * 0.01;
                p.vy *= 0.95; // Damping
                
                // Update position
                p.x += p.vx;
                p.y += p.vy;
                
                // Add slight wave motion (discipline with organic flow)
                p.y += Math.sin(state.time * 2 + p.phase) * 0.3;
                
                // Reset when off screen
                if (p.x > state.w + 20) {
                    p.x = -20;
                    p.y = state.h / 2 + (Math.random() - 0.5) * state.h * 0.4;
                    p.trail = [];
                }
                
                // Draw trail
                ctx.globalAlpha = 0.1;
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#007c87';
                if (p.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(p.trail[0].x, p.trail[0].y);
                    for (let i = 1; i < p.trail.length; i++) {
                        ctx.lineTo(p.trail[i].x, p.trail[i].y);
                    }
                    ctx.stroke();
                }
                
                // Draw particle
                ctx.globalAlpha = 1;
                let radius = 2.5;
                
                // Interactive hover effect
                if (state.hovering) {
                    const dist = Math.hypot(state.mouseX - p.x, state.mouseY - p.y);
                    if (dist < 50) {
                        radius = 2.5 + (1 - dist / 50) * 3;
                        ctx.shadowBlur = 12;
                        ctx.shadowColor = '#007c87';
                    }
                }
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            
            ctx.globalAlpha = 1;
        });

        // Animation 2: Business Model Deconstruction - Building blocks breaking apart and reforming
        initCanvasAnimation('engineerCanvas', (ctx, state) => {
            const cycle = (Math.sin(state.time * 0.5) + 1) / 2; // 0 to 1 cycle
            const blocks = [];
            
            // Main structure that breaks into pieces
            const centerX = state.w / 2;
            const centerY = state.h / 2;
            
            // Define blocks that make up the "business model"
            const blockConfig = [
                { x: 0, y: -1, w: 2, h: 0.8, label: 'Revenue' },
                { x: -1, y: 0, w: 0.9, h: 0.7, label: 'Product' },
                { x: 0.1, y: 0, w: 0.9, h: 0.7, label: 'Market' },
                { x: -0.5, y: 0.8, w: 0.8, h: 0.6, label: 'Ops' },
                { x: 0.5, y: 0.8, w: 0.8, h: 0.6, label: 'Tech' }
            ];
            
            const blockSize = Math.min(state.w, state.h) * 0.12;
            const separation = cycle * 60; // How far apart blocks move
            
            ctx.strokeStyle = '#007c87';
            ctx.fillStyle = '#007c87';
            ctx.lineWidth = 2;
            
            // Draw connection lines when assembled
            if (cycle < 0.3) {
                ctx.globalAlpha = (0.3 - cycle) / 0.3 * 0.2;
                ctx.lineWidth = 1;
                for (let i = 0; i < blockConfig.length; i++) {
                    for (let j = i + 1; j < blockConfig.length; j++) {
                        const b1 = blockConfig[i];
                        const b2 = blockConfig[j];
                        const x1 = centerX + b1.x * blockSize;
                        const y1 = centerY + b1.y * blockSize;
                        const x2 = centerX + b2.x * blockSize;
                        const y2 = centerY + b2.y * blockSize;
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
            }
            
            ctx.globalAlpha = 1;
            ctx.lineWidth = 2;
            
            // Draw blocks
            blockConfig.forEach((block, idx) => {
                const baseX = centerX + block.x * blockSize;
                const baseY = centerY + block.y * blockSize;
                
                // Calculate separation movement
                const angle = Math.atan2(block.y, block.x);
                const offsetX = Math.cos(angle) * separation;
                const offsetY = Math.sin(angle) * separation;
                
                const x = baseX + offsetX;
                const y = baseY + offsetY;
                const w = block.w * blockSize;
                const h = block.h * blockSize;
                
                // Rotation effect during deconstruction
                const rotation = cycle * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                
                // Check for hover
                let isHovered = false;
                if (state.hovering) {
                    const dist = Math.hypot(state.mouseX - x, state.mouseY - y);
                    if (dist < Math.max(w, h)) {
                        isHovered = true;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#007c87';
                    }
                }
                
                // Draw block outline
                const alpha = isHovered ? 1 : 0.7;
                ctx.globalAlpha = alpha;
                
                ctx.strokeRect(-w/2, -h/2, w, h);
                
                // Draw corner accents
                const cornerSize = 8;
                ctx.beginPath();
                // Top-left
                ctx.moveTo(-w/2, -h/2 + cornerSize);
                ctx.lineTo(-w/2, -h/2);
                ctx.lineTo(-w/2 + cornerSize, -h/2);
                // Top-right
                ctx.moveTo(w/2 - cornerSize, -h/2);
                ctx.lineTo(w/2, -h/2);
                ctx.lineTo(w/2, -h/2 + cornerSize);
                // Bottom-right
                ctx.moveTo(w/2, h/2 - cornerSize);
                ctx.lineTo(w/2, h/2);
                ctx.lineTo(w/2 - cornerSize, h/2);
                // Bottom-left
                ctx.moveTo(-w/2 + cornerSize, h/2);
                ctx.lineTo(-w/2, h/2);
                ctx.lineTo(-w/2, h/2 - cornerSize);
                ctx.stroke();
                
                // Add center dot
                ctx.fillStyle = '#007c87';
                ctx.beginPath();
                ctx.arc(0, 0, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.restore();
            });
            
            ctx.globalAlpha = 1;
        });

        // Animation 3: AI - Rotating dots around logo
        initCanvasAnimation('aiCanvas', (ctx, state) => {
            const nodeCount = 16;
            const nodes = [];
            
            // Create nodes in a circular pattern orbiting around center
            for (let i = 0; i < nodeCount; i++) {
                const angle = (i / nodeCount) * Math.PI * 2;
                const radius = Math.min(state.w, state.h) * 0.35;
                const x = state.w / 2 + Math.cos(angle + state.time * 0.4) * radius;
                const y = state.h / 2 + Math.sin(angle + state.time * 0.4) * radius;
                nodes.push({ x, y, angle: angle + state.time * 0.4 });
            }
            
            // Draw nodes (no connections)
            ctx.fillStyle = '#007c87';
            
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                
                // Vary size based on position in orbit
                const sizeVariation = Math.sin(node.angle * 2) * 0.3 + 0.7;
                let radius = 4 * sizeVariation;
                let alpha = 0.6 + sizeVariation * 0.4;
                
                // Interactive hover effect
                if (state.hovering) {
                    const dx = state.mouseX - node.x;
                    const dy = state.mouseY - node.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 60) {
                        radius = 4 + (1 - dist / 60) * 5;
                        alpha = 1;
                        
                        // Draw glow
                        ctx.shadowBlur = 18;
                        ctx.shadowColor = '#007c87';
                    }
                }
                
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
            
            ctx.globalAlpha = 1;
        });

        // Header hide/show on scroll
        let lastScroll = 0;
        const header = document.querySelector('header');

        function updateHeader() {
            const scrollY = window.scrollY;
            
            if (scrollY > 100) {
                if (scrollY > lastScroll) {
                    header.style.transform = 'translateY(-100%)';
                } else {
                    header.style.transform = 'translateY(0)';
                }
            } else {
                header.style.transform = 'translateY(0)';
            }
            lastScroll = scrollY;
        }

        window.addEventListener('scroll', updateHeader, { passive: true });

        // Update side mountains on resize
        window.addEventListener('resize', () => {
            updateBackgroundMountains();
        });

        // Team Connection Lines Animation
        const teamCanvas = document.getElementById('teamConnectionLines');
        const teamMembersContainer = document.querySelector('.team-members');
        
        if (teamCanvas && teamMembersContainer) {
            const ctx = teamCanvas.getContext('2d');
            const container = teamCanvas.closest('.team-orbit-container');
            
            // Set canvas size
            function resizeTeamCanvas() {
                const rect = container.getBoundingClientRect();
                teamCanvas.width = rect.width;
                teamCanvas.height = rect.height;
            }
            resizeTeamCanvas();
            window.addEventListener('resize', resizeTeamCanvas);
            
            // Animation variables for lightning effect
            let animationTime = 0;
            
            // Lightning path generator (based on interactive-ai-tools-lightning.js)
            function hashNoise(seed, t) {
                return Math.sin(seed * 999.91 + t * 0.13) * Math.cos(seed * 77.77 + t * 0.09);
            }
            
            function lightningPath(x1, y1, x2, y2, segs, seed, t) {
                const pts = [];
                pts.push({ x: x1, y: y1 });
                for (let i = 1; i < segs; i++) {
                    const progress = i / segs;
                    const x = x1 + (x2 - x1) * progress;
                    const y = y1 + (y2 - y1) * progress;
                    // Stronger jitter in middle
                    const jitterStrength = (1 - Math.abs(0.5 - progress) * 2);
                    const n1 = hashNoise(seed + i * 7.1, t * 1000 + animationTime);
                    const n2 = hashNoise(seed + i * 13.7, t * 1000 + animationTime * 1.3);
                    pts.push({ x: x + n1 * 12 * jitterStrength, y: y + n2 * 12 * jitterStrength });
                }
                pts.push({ x: x2, y: y2 });
                return pts;
            }
            
            // Animation loop for connection lines
            function drawConnectionLines() {
                animationTime += 1;
                ctx.clearRect(0, 0, teamCanvas.width, teamCanvas.height);
                
                const centerX = teamCanvas.width / 2;
                const centerY = teamCanvas.height / 2;
                
                // Get current rotation of container
                const computedStyle = window.getComputedStyle(teamMembersContainer);
                const transform = computedStyle.transform;
                
                let currentRotation = 0;
                if (transform && transform !== 'none') {
                    const values = transform.split('(')[1].split(')')[0].split(',');
                    const a = parseFloat(values[0]);
                    const b = parseFloat(values[1]);
                    currentRotation = Math.atan2(b, a);
                }
                
                // Find the member closest to top position (12 o'clock)
                const teamMembers = document.querySelectorAll('.team-member');
                let closestMember = null;
                let closestDistance = Infinity;
                let closestAngle = 0;
                let closestIndex = -1;
                
                teamMembers.forEach((member, index) => {
                    // Calculate base angle for each member (45° intervals)
                    const baseAngle = (index * 45) * (Math.PI / 180);
                    
                    // Add current rotation
                    const totalAngle = baseAngle + currentRotation;
                    
                    // Normalize angle to 0 to 2PI range
                    let normalizedAngle = totalAngle % (2 * Math.PI);
                    if (normalizedAngle < 0) normalizedAngle += 2 * Math.PI;
                    
                    // Calculate distance from top (0 radians or 2PI radians)
                    let distanceFromTop = Math.abs(normalizedAngle);
                    if (distanceFromTop > Math.PI) {
                        distanceFromTop = 2 * Math.PI - distanceFromTop;
                    }
                    
                    // Track the closest member to top
                    if (distanceFromTop < closestDistance) {
                        closestDistance = distanceFromTop;
                        closestMember = member;
                        closestAngle = totalAngle;
                        closestIndex = index;
                    }
                });
                
                // Only draw line if closest member is within 60 degrees of top (about 10-2 o'clock range)
                const maxDistanceRadians = (60 * Math.PI) / 180; // 60 degrees in radians
                
                if (closestMember && closestDistance <= maxDistanceRadians) {
                    // Calculate member position - orbit radius varies by screen size
                    const isMobile = window.innerWidth < 768;
                    const isSmallMobile = window.innerWidth < 480;
                    const orbitRadius = isSmallMobile ? 140 : (isMobile ? 160 : 220);
                    const memberCenterX = centerX + Math.sin(closestAngle) * orbitRadius;
                    const memberCenterY = centerY - Math.cos(closestAngle) * orbitRadius;
                    
                    // Calculate the point on the edge of the member circle closest to center
                    // Member circle radius varies by screen size
                    const memberCircleRadius = isSmallMobile ? 30 : (isMobile ? 35 : 50);
                    const angleToCenter = Math.atan2(centerY - memberCenterY, centerX - memberCenterX);
                    
                    const memberEdgeX = memberCenterX + Math.cos(angleToCenter) * memberCircleRadius;
                    const memberEdgeY = memberCenterY + Math.sin(angleToCenter) * memberCircleRadius;
                    
                    // Calculate where lightning should stop (right at the "Your Company" text)
                    // Small radius so lightning reaches very close to the text
                    const textRadius = isSmallMobile ? 22 : (isMobile ? 25 : 30); // Lightning gets very close to text
                    const angleToMember = Math.atan2(memberCenterY - centerY, memberCenterX - centerX);
                    
                    const centerEdgeX = centerX + Math.cos(angleToMember) * textRadius;
                    const centerEdgeY = centerY + Math.sin(angleToMember) * textRadius;
                    
                    // Enable additive blending for electric glow effect
                    const prevComp = ctx.globalCompositeOperation;
                    ctx.globalCompositeOperation = 'lighter';
                    
                    // Draw THREE lightning bolts with variations
                    for (let boltNum = 0; boltNum < 3; boltNum++) {
                        // Generate lightning path from center to member circle edge
                        const segments = 9;
                        const seed = closestIndex + 1.23 + (boltNum * 3.7); // Different seed for each bolt
                        const pts = lightningPath(centerEdgeX, centerEdgeY, memberEdgeX, memberEdgeY, segments, seed, 1);
                        
                        // Draw this bolt
                        ctx.beginPath();
                        pts.forEach((pt, i) => {
                            if (i === 0) ctx.moveTo(pt.x, pt.y);
                            else ctx.lineTo(pt.x, pt.y);
                        });
                        
                        // Each bolt has slightly different intensity and timing
                        const phaseShift = boltNum * 2.1;
                        const intensity = 0.6 + 0.4 * Math.sin(animationTime * 0.18 + phaseShift);
                        
                        // Main bolt is brightest, others are supporting arcs
                        const alphaMultiplier = boltNum === 0 ? 1.0 : 0.6;
                        const widthMultiplier = boltNum === 0 ? 1.0 : 0.75;
                        
                        // Rainbow colors for Randy (index 3), teal for others
                        let strokeColor, shadowColor;
                        if (closestIndex === 3) {
                            // Rainbow colors for Randy's lightning
                            const rainbowColors = ['#FF1493', '#9B30FF', '#00CED1']; // Hot pink, purple, turquoise
                            strokeColor = rainbowColors[boltNum];
                            shadowColor = rainbowColors[boltNum];
                        } else {
                            strokeColor = '#007c87';
                            shadowColor = '#007c87';
                        }
                        
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 2 * widthMultiplier;
                        ctx.globalAlpha = (0.15 + 0.35 * intensity) * alphaMultiplier;
                        ctx.shadowColor = shadowColor;
                        ctx.shadowBlur = 12 * intensity * alphaMultiplier;
                        ctx.stroke();
                    }
                    
                    // Reset
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                    ctx.globalCompositeOperation = prevComp;
                }
                
                requestAnimationFrame(drawConnectionLines);
            }
            
            // Start animation
            drawConnectionLines();
        }

        // Team Orbit Interaction
        const teamMembers = document.querySelectorAll('.team-member');
        const bioCard = document.getElementById('teamBioCard');
        let currentHoveredMember = null;

        teamMembers.forEach((member, index) => {
            member.addEventListener('mouseenter', function() {
                currentHoveredMember = member;
                
                // Pause rotation
                if (teamMembersContainer) {
                    teamMembersContainer.classList.add('paused');
                }

                // Add active class to member for styling
                this.classList.add('active');

                // Get member data
                const name = this.getAttribute('data-name');
                const title = this.getAttribute('data-title');
                const bio = this.getAttribute('data-bio');

                // Update bio card content
                bioCard.querySelector('.bio-name').textContent = name;
                bioCard.querySelector('.bio-title').textContent = title;
                bioCard.querySelector('.bio-description').textContent = bio;

                // Calculate position for bio card tooltip
                const memberRect = this.getBoundingClientRect();
                const containerRect = this.closest('.team-orbit-container').getBoundingClientRect();
                
                // Get member's center position relative to container
                const memberCenterX = memberRect.left + memberRect.width / 2 - containerRect.left;
                const memberCenterY = memberRect.top + memberRect.height / 2 - containerRect.top;
                
                // Get absolute position for viewport checking
                const memberAbsX = memberRect.left + memberRect.width / 2;
                const memberAbsY = memberRect.top + memberRect.height / 2;
                
                // Container center
                const containerCenterX = containerRect.width / 2;
                const containerCenterY = containerRect.height / 2;
                
                // Expanded photo size
                const expandedPhotoSize = 140;
                const bioCardWidth = 280;
                const gap = 20; // Gap between photo edge and card
                const viewportPadding = 20; // Minimum distance from viewport edge
                
                // Remove old position classes
                bioCard.classList.remove('position-left', 'position-right', 'position-top', 'position-bottom');
                
                // Temporarily show card to get its actual height
                bioCard.style.visibility = 'hidden';
                bioCard.style.opacity = '1';
                bioCard.classList.add('active');
                const bioCardHeight = bioCard.offsetHeight;
                bioCard.style.visibility = '';
                bioCard.style.opacity = '';
                
                let bioX, bioY, position;
                let finalTransform;
                
                // Try positions in order of preference and check viewport bounds
                const positions = [];
                
                // Option 1: Top
                if (memberCenterY < containerCenterY * 0.7) {
                    positions.push('top', 'right', 'left');
                }
                // Option 2: Left side - prefer right
                else if (memberCenterX < containerCenterX) {
                    positions.push('right', 'left', 'top');
                }
                // Option 3: Right side - prefer left
                else {
                    positions.push('left', 'right', 'top');
                }
                
                // Try positions: right/left first, then bottom as fallback
                const forcedPositions = [];
                
                // Prefer right if on left side, left if on right side, then try bottom
                if (memberCenterX < containerCenterX) {
                    forcedPositions.push('right', 'left', 'bottom');
                } else {
                    forcedPositions.push('left', 'right', 'bottom');
                }
                
                // Try each position until we find one that fits
                for (const pos of forcedPositions) {
                    let testX, testY, testTransform;
                    let cardLeft, cardRight, cardTop, cardBottom;
                    
                    if (pos === 'right') {
                        testX = memberCenterX + (expandedPhotoSize / 2) + gap;
                        testY = memberCenterY;
                        testTransform = 'translateY(-50%)';
                        
                        const absX = containerRect.left + testX;
                        const absY = containerRect.top + testY;
                        cardLeft = absX;
                        cardRight = absX + bioCardWidth;
                        cardTop = absY - (bioCardHeight / 2);
                        cardBottom = absY + (bioCardHeight / 2);
                    }
                    else if (pos === 'left') {
                        testX = memberCenterX - (expandedPhotoSize / 2) - gap;
                        testY = memberCenterY;
                        testTransform = 'translate(-100%, -50%)';
                        
                        const absX = containerRect.left + testX;
                        const absY = containerRect.top + testY;
                        cardLeft = absX - bioCardWidth;
                        cardRight = absX;
                        cardTop = absY - (bioCardHeight / 2);
                        cardBottom = absY + (bioCardHeight / 2);
                    }
                    else { // bottom
                        testX = memberCenterX;
                        testY = memberCenterY + (expandedPhotoSize / 2) + gap;
                        testTransform = 'translate(-50%, 0)';
                        
                        const absX = containerRect.left + testX;
                        const absY = containerRect.top + testY;
                        cardLeft = absX - (bioCardWidth / 2);
                        cardRight = absX + (bioCardWidth / 2);
                        cardTop = absY;
                        cardBottom = absY + bioCardHeight;
                    }
                    
                    // Check if this position fits in viewport
                    const fitsInViewport = 
                        cardLeft >= viewportPadding &&
                        cardRight <= window.innerWidth - viewportPadding &&
                        cardTop >= viewportPadding &&
                        cardBottom <= window.innerHeight - viewportPadding;
                    
                    if (fitsInViewport) {
                        bioX = testX;
                        bioY = testY;
                        position = pos;
                        finalTransform = testTransform;
                        break;
                    }
                }
                
                // If no position fits perfectly, use bottom and clamp to viewport
                if (!position) {
                    // Use bottom position as last resort
                    position = 'bottom';
                    bioX = memberCenterX;
                    bioY = memberCenterY + (expandedPhotoSize / 2) + gap;
                    finalTransform = 'translate(-50%, 0)';
                    
                    // Clamp horizontal position to viewport
                    const absX = containerRect.left + bioX;
                    const cardHalfWidth = bioCardWidth / 2;
                    const minX = viewportPadding + cardHalfWidth;
                    const maxX = window.innerWidth - viewportPadding - cardHalfWidth;
                    
                    if (absX - cardHalfWidth < viewportPadding) {
                        // Too far left - move right
                        bioX = minX - containerRect.left;
                    } else if (absX + cardHalfWidth > window.innerWidth - viewportPadding) {
                        // Too far right - move left
                        bioX = maxX - containerRect.left;
                    }
                    
                    // Clamp vertical position to viewport
                    const absY = containerRect.top + bioY;
                    if (absY + bioCardHeight > window.innerHeight - viewportPadding) {
                        // Too low - move up
                        bioY = (window.innerHeight - viewportPadding - bioCardHeight) - containerRect.top;
                    }
                }
                
                // Apply position
                bioCard.style.left = bioX + 'px';
                bioCard.style.top = bioY + 'px';
                bioCard.style.transform = finalTransform;
                bioCard.classList.add('position-' + position);
                
                // Show bio card
                bioCard.classList.add('active');
            });

            member.addEventListener('mouseleave', function(e) {
                hideBioCard(this);
            });
        });

        function hideBioCard(member) {
            if (member) {
                member.classList.remove('active');
            }
            
            // Remove all active classes
            teamMembers.forEach(m => m.classList.remove('active'));
            
            currentHoveredMember = null;
            bioCard.classList.remove('active', 'left', 'right');
            
            // Resume rotation
            if (teamMembersContainer) {
                teamMembersContainer.classList.remove('paused');
            }
        }
    </script>


    <!-- CTA Mountains Scroll Animation (Same as top mountains) -->
    <script>
        const ctaLeftMountain = document.querySelector('.cta-left-mountain');
        const ctaRightMountain = document.querySelector('.cta-right-mountain');
        const ctaSection = document.getElementById('contact');

        function updateCtaMountains() {
            if (!ctaSection) return;
            
            const scrollY = window.scrollY;
            const windowHeight = window.innerHeight;
            const sectionTop = ctaSection.offsetTop;
            const sectionHeight = ctaSection.offsetHeight;
            
            // Add visible class for highlight animation when section is in view
            const sectionRect = ctaSection.getBoundingClientRect();
            if (sectionRect.top < windowHeight * 0.8 && !ctaSection.classList.contains('visible')) {
                ctaSection.classList.add('visible');
            }
            
            if (window.innerWidth <= 768) return; // Skip mountain animation on mobile
            
            // Calculate scroll progress through the CTA section
            const scrollProgress = Math.max(0, Math.min(1, (scrollY - sectionTop + windowHeight) / (sectionHeight + windowHeight)));
            
            // Mountains start at -300px and rise up to -400px
            const startPosition = -300;
            const endPosition = -400;
            const currentPosition = startPosition + (scrollProgress * (endPosition - startPosition));
            
            if (ctaLeftMountain) ctaLeftMountain.style.bottom = `${currentPosition}px`;
            if (ctaRightMountain) ctaRightMountain.style.bottom = `${currentPosition}px`;
        }

        window.addEventListener('scroll', updateCtaMountains, { passive: true });
        updateCtaMountains();
        
        // Update on resize
        window.addEventListener('resize', () => {
            updateCtaMountains();
        });
    </script>

    <!-- CTA Questions Slide-in Animation -->
    <script>
        const ctaButton = document.getElementById('ctaButton');
        const ctaQuestionCards = document.querySelectorAll('.cta-question-card');
        const ctaQuestionsContainer = document.getElementById('ctaQuestions');
        let questionsTriggered = false;
        
        function updateCtaQuestions() {
            if (!ctaButton || ctaQuestionCards.length === 0) return;
            
            const buttonRect = ctaButton.getBoundingClientRect();
            const windowHeight = window.innerHeight;
            
            // Initial slide-in when "Let's Talk" button starts to enter viewport
            if (!questionsTriggered && buttonRect.top < windowHeight && buttonRect.bottom > 0) {
                ctaQuestionCards.forEach((card, index) => {
                    setTimeout(() => {
                        card.classList.add('visible');
                    }, index * 150); // Stagger each card by 150ms
                });
                questionsTriggered = true;
            }
            
            // Continue moving cards toward center as user scrolls (desktop only)
            if (questionsTriggered && ctaQuestionsContainer && window.innerWidth > 768) {
                const containerRect = ctaQuestionsContainer.getBoundingClientRect();
                
                // Calculate scroll progress through questions section
                let progress = 0;
                if (containerRect.top < windowHeight) {
                    progress = Math.min(1, Math.max(0, (windowHeight - containerRect.top) / (windowHeight * 0.5)));
                }
                
                // Move cards away from center based on scroll progress
                // Card 1 (left): starts at 25%, moves to 40% (further left)
                const card1Margin = 0 + (progress * 15);
                ctaQuestionCards[0].style.marginLeft = `${card1Margin}%`;
                
                // Card 2 (right): starts at 25%, moves to 40% (further right)
                const card2Margin = 0 + (progress * 15);
                ctaQuestionCards[1].style.marginRight = `${card2Margin}%`;
                
                // Card 3 (left side): starts at 5%, moves to 20% (further left)
                const card3Margin = 5 + (progress * 25);
                ctaQuestionCards[2].style.marginLeft = `${card3Margin}%`;
            }
        }
        
        window.addEventListener('scroll', updateCtaQuestions, { passive: true });
        updateCtaQuestions(); // Check on load
    </script>

    <!-- Vanta.js Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.trunk.min.js"></script>
    <script>
        // Initialize Vanta.js for Hero and Pricing sections
        let vantaHeroEffect;
        let vantaPricingEffect;
        
        function initVanta() {
            // Hero section Vanta effect
            if (!vantaHeroEffect) {
                vantaHeroEffect = VANTA.TRUNK({
                    el: ".hero",
                    mouseControls: true,
                    touchControls: true,
                    gyroControls: false,
                    minHeight: 200.00,
                    minWidth: 200.00,
                    scale: 1.50,
                    scaleMobile: 1.50,
                    color: 0x14b1ab,
                    backgroundColor: 0xffffff,
                    spacing: 5.00,
                    chaos: 8.00,
                    speed: 0.2
                });
                
                // Position camera higher
                setTimeout(() => {
                    if (vantaHeroEffect && vantaHeroEffect.camera) {
                        vantaHeroEffect.camera.position.y = 150;
                    }
                }, 100);
            }
            
            // Pricing section Vanta effect
            if (!vantaPricingEffect) {
                vantaPricingEffect = VANTA.TRUNK({
                    el: "#pricing",
                    mouseControls: true,
                    touchControls: true,
                    gyroControls: false,
                    minHeight: 200.00,
                    minWidth: 200.00,
                    scale: 1.50,
                    scaleMobile: 1.50,
                    color: 0x14b1ab,
                    backgroundColor: 0xffffff,
                    spacing: 5.00,
                    chaos: 8.00,
                    speed: 0.2
                });
                
                // Position camera higher
                setTimeout(() => {
                    if (vantaPricingEffect && vantaPricingEffect.camera) {
                        vantaPricingEffect.camera.position.y = 150;
                    }
                }, 100);
            }
        }
        
        // Initialize on load
        initVanta();
    </script>

    <!-- Smooth Scroll for Anchor Links -->
    <script>
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
    </script>
</body>
</html>
